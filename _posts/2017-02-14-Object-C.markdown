---
layout: post
title:  "回味Object-C"
date:   2017-02-14 18:32:40 
img: zagreb_city.jpg
description: 今天开始搭建属于自己的一个应用blog，重新回过头来仔细体味基础
---


## runtime
Object-C使用了面向对象特性和消息转发机制。


对于C语言，函数的调用在编译的时候回决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。OC的函数调用为消息转发机制，属于动态调用。在编译的时候并不能决定真正调用哪个函数（事实证明，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错，而C语言在编译阶段就会报错），只有在真正运行的时候才会根据函数的名称找打对应的函数开调用。


先看看runtime消息发送是怎么实现的：
首先，编译器将代码[obj makeText]转化为obj_msgsend(obj,@select(makeText))，在obj_msgsend函数里，首先统统obj的isa指针找到obj对应的class。在Class中先去cache尊重通过SEL查找对应函数method，若cache中未找到，再去methodList里查找，若methodList中也没有找到，则去superClass中查找。若找到，将method加入到cache中，以便下次查找，并通过method中的函数指针跳转到对应的函数中执行。
##RunLoop
1.RunLoop,是多线程的法宝，一个线程一次只能执行一个任务，执行完任务就会退出线程。主线程执行完即时任务会继续等待接受任务事件而不退出。非主线程通常是执行完某一个任务，就归还资源，因此默认是不执行RunLoop的。

2.每个子线程都有其对应的RunLoop,只是默认只有主线程的RunLoop是启动，其他的子线程的RunLoop默认是不启动的，若要启动则需要手动启动。

3.NSRunLoop使用实例：如果要让NSTimer的方法，可以在任何情况下都有回调，需要将NSTimer放置到指定的CommonMode模式下，这样就可以不受其他模式的影响，正常显示时间点。

## 深浅拷贝
浅拷贝，拷贝过后指向的是同一个内存资源，复制的只不过是一个指针，对象本身资源还是只有一份，所以我们对拷贝后的进行修改操作，同样会原来对象的改变，这就是浅拷贝。

浅拷贝好比你和你的影子，你完蛋，你的影子就完蛋

深拷贝好比你和你的克隆人，你完蛋，你的克隆人还是活着

## FMDB线程安全
原理：文件数据库sqlite，同一时刻允许多个线程/进程读，但是同一时刻只允许一个线程写。在执行写的操作时，数据库文件被锁定，此时任何的读/写操作都是被阻塞，如果阻塞超过5秒钟，就报”database is locked“

FMDatebaseQueue 就是为了避免并发的访问数据的问题，因为对数据库的访问可能是随机，不同线程间的请求，所以FMDataQueue通过内部创建一个同步的dispatch_queue_t来初始化Database，所以当我们在主线程调用初始化database的时候，后续的所有操作都是同步执行的，这样就变成线程安全了。

如果遇到大批量的更新操作，需要大批量的访问数据库，这样在后台执行完之前，还是会阻塞主线程，针对这个问题，（1）我们可以分批更新数据量，比如分10次请求（2）不要放在主线程中发起初始化和请求
